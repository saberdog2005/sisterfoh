<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surf's Up 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: monospace;
            background: #000;
            overflow: hidden;
        }
        #gameCanvas {
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid black;
            z-index: 1000;
            text-align: center;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .controls button {
            width: 60px;
            height: 60px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        Score: <span id="score">0</span> | Waves: <span id="wavesRidden">0</span> | Combo: <span id="combo">0</span> | Time: <span id="surfTime">0</span>s
    </div>
    <div class="controls">
        <button id="leftButton">Left</button>
        <button id="rightButton">Right</button>
        <button id="upButton">Up</button>
        <button id="downButton">Down</button>
    </div>
    <div id="gameOverModal">
        <h2>Game Over</h2>
        <p>Final Score: <span id="finalScore"></span></p>
        <p id="highScoreMessage" style="display:none">HIGH SCORE!</p>
        <h4>High Scores</h4>
        <ol id="high-scores"></ol>
        <button id="resetButton">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Constants
        const WIDTH = 80;
        const DEPTH = 50;
        const WAVE_INTERVAL = 2000;
        const WAVE_SPEED = 3;
        const ACCELERATION = 20;
        const PLAYER_SPEED = 10;
        const TOLERANCE = 3;

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Ocean
        const oceanGeometry = new THREE.PlaneGeometry(WIDTH, DEPTH, WIDTH - 1, DEPTH - 1);
        const oceanMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                lightPos: { value: new THREE.Vector3(10, 20, 10) }
            },
            vertexShader: `
                uniform float time;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vec3 pos = position;
                    pos.z += sin(pos.x * 0.1 + time) * cos(pos.y * 0.1 + time) * 2.0;
                    vNormal = normalize(vec3(sin(pos.x * 0.1 + time), cos(pos.y * 0.1 + time), 1.0));
                    vPosition = pos;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 lightPos;
                varying vec3 vNormal;
                varying vec3 vPosition;
                void main() {
                    vec3 lightDir = normalize(lightPos - vPosition);
                    float diff = max(dot(vNormal, lightDir), 0.0);
                    vec3 baseColor = vec3(0.0, 0.5, 1.0);
                    vec3 color = baseColor * (0.3 + diff * 0.7);
                    gl_FragColor = vec4(color, 0.8);
                }
            `,
            side: THREE.DoubleSide,
            transparent: true
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        scene.add(ocean);

        // Beach
        const beachGeometry = new THREE.PlaneGeometry(WIDTH, 5, WIDTH - 1, 4);
        const beachMaterial = new THREE.MeshBasicMaterial({ color: 0xEDC9AF });
        const beach = new THREE.Mesh(beachGeometry, beachMaterial);
        beach.position.y = -DEPTH / 2 + 2.5;
        beach.rotation.x = -Math.PI / 2;
        scene.add(beach);

        // Player (Surfer)
        const surferGeometry = new THREE.BoxGeometry(1, 1, 1);
        const surferMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const surfer = new THREE.Mesh(surferGeometry, surferMaterial);
        surfer.position.set(0, -DEPTH / 2 + 1, 1);
        scene.add(surfer);

        // AI Surfers
        const aiSurfers = [];
        for (let i = 0; i < 3; i++) {
            const ai = new THREE.Mesh(surferGeometry, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            ai.position.set(Math.random() * WIDTH - WIDTH / 2, Math.random() * (DEPTH - 10) - DEPTH / 2 + 5, 1);
            scene.add(ai);
            aiSurfers.push({ mesh: ai, attachedWave: null });
        }

        // Camera Setup
        camera.position.set(0, -20, 20);
        camera.lookAt(0, 0, 0);

        // Game State
        let time = 0;
        let gameTime = 0;
        let waves = [];
        let surferX = 0;
        let surferY = -DEPTH / 2 + 1;
        let surferVx = 0;
        let attachedWave = null;
        let score = 0;
        let wavesRidden = 0;
        let combo = 0;
        let maxCombo = 0;
        let surfTime = 0;
        let previousAttachedWave = null;
        let highScores = JSON.parse(localStorage.getItem('highScores')) || Array(10).fill(0);
        let leftPressed = false;
        let rightPressed = false;
        let upPressed = false;
        let downPressed = false;

        // Wave Generation
        function createWave() {
            const amplitude = Math.random() * 5 + 2;
            const frequency = Math.random() * 0.1 + 0.05;
            const phase = Math.random() * Math.PI * 2;
            const isJackpot = Math.random() < 0.1;
            waves.push({ amplitude, frequency, phase, y: DEPTH / 2, speed: WAVE_SPEED, isJackpot });
        }
        setInterval(createWave, WAVE_INTERVAL);

        // Game Loop
        function animate() {
            requestAnimationFrame(animate);
            time += 0.05;
            gameTime += 0.05;
            oceanMaterial.uniforms.time.value = time;

            // Update Waves
            waves.forEach(wave => {
                wave.y -= wave.speed * 0.05;
            });
            waves = waves.filter(wave => wave.y > -DEPTH / 2);

            // Player Movement
            if (leftPressed) surferVx -= ACCELERATION * 0.05;
            if (rightPressed) surferVx += ACCELERATION * 0.05;
            surferX += surferVx * 0.05;
            surferVx *= 0.9;
            surferX = Math.max(-WIDTH / 2, Math.min(WIDTH / 2, surferX));
            if (!attachedWave) {
                if (upPressed) surferY += PLAYER_SPEED * 0.05;
                if (downPressed) surferY -= PLAYER_SPEED * 0.05;
                surferY = Math.max(-DEPTH / 2 + 1, Math.min(DEPTH / 2, surferY));
            }

            // Wave Attachment
            if (!attachedWave) {
                for (let wave of waves) {
                    const crestX = wave.amplitude * Math.sin(wave.frequency * wave.y + wave.phase);
                    if (Math.abs(surferY - wave.y) < 1 && Math.abs(surferX - crestX) < TOLERANCE) {
                        attachedWave = wave;
                        break;
                    }
                }
            } else {
                const crestX = attachedWave.amplitude * Math.sin(attachedWave.frequency * attachedWave.y + attachedWave.phase);
                surferX = crestX;
                surferY = attachedWave.y;
                if (Math.abs(surferX - crestX) > TOLERANCE || (upPressed || downPressed)) {
                    attachedWave = null;
                } else {
                    surfTime += 0.05;
                }
            }

            // Scoring
            if (attachedWave && attachedWave !== previousAttachedWave) {
                combo++;
                maxCombo = Math.max(maxCombo, combo);
                wavesRidden++;
                score += 100 * combo * (attachedWave.isJackpot ? 5 : 1);
            }
            if (attachedWave) score += 1;
            previousAttachedWave = attachedWave;

            // AI Surfers
            aiSurfers.forEach(ai => {
                if (!ai.attachedWave) {
                    let nearestWave = waves.reduce((closest, wave) => {
                        const dist = Math.abs(wave.y - ai.mesh.position.y);
                        return dist < Math.abs(closest.y - ai.mesh.position.y) ? wave : closest;
                    }, waves[0] || { y: DEPTH / 2 });
                    const crestX = nearestWave.amplitude * Math.sin(nearestWave.frequency * nearestWave.y + nearestWave.phase);
                    ai.mesh.position.x += Math.sign(crestX - ai.mesh.position.x) * 0.5;
                    ai.mesh.position.y -= Math.sign(ai.mesh.position.y - nearestWave.y) * 0.5;
                    if (Math.abs(ai.mesh.position.y - nearestWave.y) < 1 && Math.abs(ai.mesh.position.x - crestX) < TOLERANCE) {
                        ai.attachedWave = nearestWave;
                    }
                } else {
                    const crestX = ai.attachedWave.amplitude * Math.sin(ai.attachedWave.frequency * ai.attachedWave.y + ai.attachedWave.phase);
                    ai.mesh.position.x = crestX;
                    ai.mesh.position.y = ai.attachedWave.y;
                    if (Math.abs(ai.mesh.position.x - crestX) > TOLERANCE) ai.attachedWave = null;
                }
            });

            // Update Player Position
            surfer.position.set(surferX, surferY, 1);

            // Camera Tilt
            const tilt = Math.min(Math.max(surferVx * 0.01, -0.2), 0.2);
            camera.rotation.z = -tilt;

            // HUD Update
            document.getElementById('score').textContent = Math.floor(score);
            document.getElementById('wavesRidden').textContent = wavesRidden;
            document.getElementById('combo').textContent = combo;
            document.getElementById('surfTime').textContent = Math.floor(surfTime);

            // Game Over Check (e.g., falling off screen)
            if (surferY < -DEPTH / 2 + 1 && !attachedWave) {
                gameOver();
                return;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Game Over
        function gameOver() {
            document.getElementById('gameOverModal').style.display = 'block';
            document.getElementById('finalScore').textContent = Math.floor(score);
            updateHighScores(Math.floor(score));
            if (score > highScores[9]) document.getElementById('highScoreMessage').style.display = 'block';
            else document.getElementById('highScoreMessage').style.display = 'none';
        }

        // Reset Game
        function resetGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            time = 0;
            gameTime = 0;
            waves = [];
            surferX = 0;
            surferY = -DEPTH / 2 + 1;
            surferVx = 0;
            attachedWave = null;
            score = 0;
            wavesRidden = 0;
            combo = 0;
            maxCombo = 0;
            surfTime = 0;
            previousAttachedWave = null;
            aiSurfers.forEach(ai => {
                ai.mesh.position.set(Math.random() * WIDTH - WIDTH / 2, Math.random() * (DEPTH - 10) - DEPTH / 2 + 5, 1);
                ai.attachedWave = null;
            });
            animate();
        }

        // High Scores
        function updateHighScores(newScore) {
            highScores.push(newScore);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 10);
            localStorage.setItem('highScores', JSON.stringify(highScores));
            document.getElementById('high-scores').innerHTML = highScores.map(s => `<li>${s}</li>`).join('');
        }

        // Input Handling
        document.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft') leftPressed = true;
            if (e.key === 'ArrowRight') rightPressed = true;
            if (e.key === 'ArrowUp') upPressed = true;
            if (e.key === 'ArrowDown') downPressed = true;
        });
        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft') leftPressed = false;
            if (e.key === 'ArrowRight') rightPressed = false;
            if (e.key === 'ArrowUp') upPressed = false;
            if (e.key === 'ArrowDown') downPressed = false;
        });

        document.getElementById('leftButton').addEventListener('touchstart', e => { e.preventDefault(); leftPressed = true; });
        document.getElementById('leftButton').addEventListener('touchend', e => { e.preventDefault(); leftPressed = false; });
        document.getElementById('rightButton').addEventListener('touchstart', e => { e.preventDefault(); rightPressed = true; });
        document.getElementById('rightButton').addEventListener('touchend', e => { e.preventDefault(); rightPressed = false; });
        document.getElementById('upButton').addEventListener('touchstart', e => { e.preventDefault(); upPressed = true; });
        document.getElementById('upButton').addEventListener('touchend', e => { e.preventDefault(); upPressed = false; });
        document.getElementById('downButton').addEventListener('touchstart', e => { e.preventDefault(); downPressed = true; });
        document.getElementById('downButton').addEventListener('touchend', e => { e.preventDefault(); downPressed = false; });

        document.getElementById('resetButton').addEventListener('click', resetGame);

        // Initial High Scores Display
        document.getElementById('high-scores').innerHTML = highScores.map(s => `<li>${s}</li>`).join('');
    </script>
</body>
</html>
