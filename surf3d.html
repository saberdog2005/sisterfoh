<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surf's Up - Enhanced Version</title>
    <style>
        body { margin: 0; }
        #mainCanvas { width: 100%; height: 100vh; }
        #minimap { position: absolute; top: 10px; right: 10px; width:200px; height:200px; }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <canvas id="minimap"></canvas>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.175.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.175.0/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'https://unpkg.com/three@0.175.0/examples/jsm/loaders/DRACOLoader.js';
        import { SimplexNoise } from 'https://unpkg.com/three@0.175.0/examples/jsm/math/SimplexNoise.js';

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('mainCanvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 100, 0);
        scene.add(light);

        // Terrain generation
        function generateTerrain(width, depth, scale) {
            const geometry = new THREE.PlaneGeometry(width, depth, Math.floor(width / scale), Math.floor(depth / scale));
            const noise = new SimplexNoise();
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                let y = noise.noise(x / 100, z / 100) * 15;
                if (x >= width / 2) y = Math.min(y + (Math.random() * 5 - 2), 2);
                vertices[i + 1] = y;
            }
            geometry.computeVertexNormals();
            const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xFFFFFF });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotateX(-Math.PI / 2);
            return mesh;
        }

        const terrain = generateTerrain(256, 256, 8);
        scene.add(terrain);

        // Water plane
        const waterGeometry = new THREE.PlaneGeometry(300, 300, 100, 100);
        const waterMaterial = new THREE.ShaderMaterial({
            uniforms: { time: { value: 0 } },
            vertexShader: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    float wave = sin(pos.x * 0.1 + time) * cos(pos.z * 0.1 + time) * 2.0;
                    pos.y += wave;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                void main() {
                    gl_FragColor = vec4(0.2, 0.4, 0.6, 0.8);
                }
            `
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotateX(-Math.PI / 2);
        scene.add(water);

        // Player setup (placeholder until model is loaded)
        const playerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 6);
        const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        let player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 2;
        scene.add(player);

        // Load player model
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        loader.load('path/to/surfer.glb', function (gltf) {
            scene.remove(player); // remove placeholder
            player = gltf.scene;
            player.scale.set(1, 1, 1);
            player.position.y = 2;
            scene.add(player);
        });

        // Direction line
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const directionLineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, -5)]);
        const directionLine = new THREE.Line(directionLineGeometry, lineMaterial);
        scene.add(directionLine);

        // Coconut setup
        const coconutGeometry = new THREE.SphereGeometry(0.5);
        const coconutMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
        const coconuts = [];

        // Raycaster for mouse
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // Controls
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let coconutInventory = 0;
        window.addEventListener('keydown', e => {
            if (e.key == 'w' || e.key == 'W' || e.key == 'ArrowUp') moveForward = true;
            if (e.key == 's' || e.key == 'S' || e.key == 'ArrowDown') moveBackward = true;
            if (e.key == 'a' || e.key == 'A' || e.key == 'ArrowLeft') moveLeft = true;
            if (e.key == 'd' || e.key == 'D' || e.key == 'ArrowRight') moveRight = true;
            if (e.code == 'Space' && coconutInventory > 0) {
                coconutInventory -= 1;
                const coconut = new THREE.Mesh(coconutGeometry, coconutMaterial);
                coconut.position.copy(player.position);
                scene.add(coconut);
                raycaster.setFromCamera(mouse, camera);
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -player.position.y);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersection);
                const direction = intersection.sub(player.position).normalize();
                coconut.velocity = direction.multiplyScalar(10);
                coconut.velocity.y = 5; // initial upward velocity
                coconuts.push(coconut);
            }
            if (e.key == 'b' && isNearIsland()) {
                coconutInventory += 1;
            }
        });
        window.addEventListener('keyup', e => {
            if (e.key == 'w' || e.key == 'W' || e.key == 'ArrowUp') moveForward = false;
            if (e.key == 's' || e.key == 'S' || e.key == 'ArrowDown') moveBackward = false;
            if (e.key == 'a' || e.key == 'A' || e.key == 'ArrowLeft') moveLeft = false;
            if (e.key == 'd' || e.key == 'D' || e.key == 'ArrowRight') moveRight = false;
        });

        // Player movement
        let velocity = new THREE.Vector3(0, 0, 0);
        const speed = 10;
        function updatePlayer(dt) {
            velocity.set(0, 0, 0);
            if (moveForward) velocity.z = -speed;
            if (moveBackward) velocity.z = speed;
            if (moveLeft) velocity.x = -speed;
            if (moveRight) velocity.x = speed;

            player.position.add(velocity.clone().multiplyScalar(dt));
            const t = waterMaterial.uniforms.time.value;
            player.position.y = getWaterHeight(player.position.x, player.position.z, t) + 1 + Math.sin(t * 2) * 0.5;

            if (velocity.length() > 0) {
                player.rotation.y = Math.atan2(velocity.x, velocity.z);
            }
        }

        function getWaterHeight(x, z, t) {
            return Math.sin(x * 0.1 + t) * Math.cos(z * 0.1 + t) * 2.0;
        }

        // Minimap setup
        const miniMapScene = new THREE.Scene();
        const miniMapCamera = new THREE.OrthographicCamera(-16, 16, 16, -16, -16, 16);
        miniMapCamera.position.y = 50;
        miniMapCamera.lookAt(0, 0, 0);

        const miniMapRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('minimap') });
        miniMapRenderer.setSize(200, 200);

        const miniMapTerrain = terrain.clone();
        miniMapTerrain.material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
        miniMapScene.add(miniMapTerrain);

        function renderMiniMap() {
            miniMapCamera.position.set(player.position.x, 50, player.position.z);
            miniMapCamera.lookAt(player.position.x, 0, player.position.z);
            miniMapRenderer.render(miniMapScene, miniMapCamera);
        }

        // Islands (example)
        const islandGeometry = new THREE.SphereGeometry(5, 32, 32);
        const islandMaterial = new THREE.MeshStandardMaterial({ color: 0xdeb887 });
        const island = new THREE.Mesh(islandGeometry, islandMaterial);
        island.position.set(50, 0, 50);
        scene.add(island);
        const islands = [island];

        function isNearIsland() {
            for (let isl of islands) {
                if (player.position.distanceTo(isl.position) < 10) {
                    return true;
                }
            }
            return false;
        }

        // Main loop
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);

            const timeNow = performance.now();
            const dt = (timeNow - lastTime) / 1000;
            lastTime = timeNow;

            // Update time uniform for water shader
            waterMaterial.uniforms.time.value += dt;

            // Update player
            updatePlayer(dt);

            // Update direction line
            directionLine.position.copy(player.position);
            directionLine.rotation.y = player.rotation.y;

            // Update coconuts
            const gravity = -9.81;
            coconuts.forEach(c => {
                c.velocity.y += gravity * dt;
                c.position.add(c.velocity.clone().multiplyScalar(dt));
                if (c.position.y < 0) {
                    scene.remove(c);
                }
            });
            coconuts = coconuts.filter(c => c.position.y >= 0);

            // Update camera
            const angle = player.rotation.y;
            const offset = 10;
            const cameraPosition = new THREE.Vector3(
                player.position.x - Math.sin(angle) * offset,
                player.position.y + 5,
                player.position.z - Math.cos(angle) * offset
            );
            camera.position.lerp(cameraPosition, 0.1);
            camera.lookAt(player.position);

            // Render main scene
            renderer.clear();
            renderer.render(scene, camera);

            // Render minimap
            renderMiniMap();
        }

        animate();
    </script>
</body>
</html>
