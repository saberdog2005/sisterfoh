<!DOCTYPE html>
<html lang="en">
<head>
    <!-- SOFTWARE COPYRIGHT Â© 2025-2035 SABERDOG LLC, ALL RIGHTS RESERVED -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surf's Up</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: monospace;
            transition: background-color 1s ease;
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
            width: 100%;
        }
        #waterOverlay {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100% - 60px);
            background-color: rgb(0, 0, 139, 0.6);
            pointer-events: none;
            z-index: 1;
        }
        #gameGrid {
            width: 100%;
            height: 600px;
            font-size: 12px;
            white-space: pre;
            background: transparent;
            overflow: hidden;
            transition: transform 0.1s ease;
            z-index: 2;
        }
        #gameGrid div {
            height: 12px;
            line-height: 12px;
        }
        #scoreDisplay {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: limegreen;
            font-size: 20px;
            z-index: 3;
        }
        #joystickArea {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 10vw;
            height: 10vw;
            background: #ccc;
            z-index: 3;
        }
        .controls {
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 80%;
            max-width: 600px;
        }
        .controls button {
            width: 60px;
            height: 60px;
            margin: 5px;
        }
        .surfer {
            color: red;
            font-weight: bold;
        }
        #gameOverModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid black;
            z-index: 1000;
        }
        .wave-color-0 { color: #ADD8E6; }
        .wave-color-1 { color: #87CEEB; }
        .wave-color-2 { color: #00BFFF; }
        .wave-color-3 { color: #1E90FF; }
        .wave-color-4 { color: #0000CD; }
        .sand-color-0 { color: #FFFF00; } /* Yellow color for beach */
        .sand-color-1 { color: #DEB887; }
        .sand-color-2 { color: #CD853F; }
        .sand-color-3 { color: #A0522D; }
        .sand-color-4 { color: #8B4513; }
        .shark { color: #FF0000; }
        .boat { color: #8B4513; }
        .ship { color: #808080; }
        .lobster { color: #FFA500; }
        .fish { color: #FFFF00; }
        .umbrella { color: #FF4500; }
        .person { color: #8B4513; }
        .sky-day { color: #87CEEB; }
        .sky-sunset { color: #FFA500; }
        .sky-night { color: #00008B; }
        .sky-sunrise { color: #87CEEB; }
        .sun { color: yellow; }
        .moon { color: white; }
        .star { color: white; }
        h1, h2 {
            color: white;
        }
        @media (max-width: 600px) {
            .controls {
                display: none;
            }
        }
    </style>
</head>
<body>
    <h1 style="text-align: center;">Surf's Up</h1>
    <h2 style="text-align: center;">A Video Game by SABERDOG LLC</h2>
    <div class="game-container">
        <div id="waterOverlay"></div>
        <div id="gameGrid"></div>
        <div id="scoreDisplay">
            Score: <span id="current-score">0</span>
        </div>
        <div id="joystickArea"></div>
    </div>
    <div id="gameOverModal">
        <h2>Game Over</h2>
        <p>Your score: <span id="finalScore"></span></p>
        <p id="highScoreMessage" style="display:none">HIGH SCORE.</p>
        <h4>High Scores</h4>
        <ol id="high-scores"></ol>
        <button id="resetButton">Play Again</button>
    </div>
    <script>
        // Constants
        const ROWS = 50;
        const COLS = 80;
        const VIRTUAL_WIDTH = 200;
        const WAVE_INTERVAL = 1000; // ms
        const WAVE_SPEED = 3; // rows per second
        const ACCELERATION = 20; // columns per second squared
        const WAVE_ACCELERATION = 30; // Higher acceleration on waves
        const PLAYER_SPEED = 10; // rows per second
        const GRAVITY = 50; // rows per second squared
        const JUMP_VELOCITY = 10; // rows per second
        const TOLERANCE = 3; // columns
        const DT = 0.1; // seconds per frame
        const UMBRELLA_ROW = ROWS - 2;
        const WAVE_COLORS = ['#ADD8E6', '#87CEEB', '#00BFFF', '#1E90FF', '#0000CD'];
        const sandColors = ['#FFFF00', '#DEB887', '#CD853F', '#A0522D', '#8B4513'];
        const SHARK_MIN_ROW = 5;
        const SHARK_MAX_ROW = 45;
        const SHARK_SPEED_MIN = 10;
        const SHARK_SPEED_MAX = 20;
        const BOAT_MIN_ROW = 5;
        const BOAT_MAX_ROW = 10;
        const BOAT_SPEED_MIN = 5;
        const BOAT_SPEED_MAX = 10;
        const BOAT_WAVE_INTERVAL_MIN = 2;
        const BOAT_WAVE_INTERVAL_MAX = 5;

        // Game state
        let t = 0;
        let gameTime = 0;
        let activeWaves = [];
        let sharks = [];
        let boats = [];
        let lobsters = [];
        let fish = [];
        let surferX = VIRTUAL_WIDTH / 2;
        let surferY = ROWS - 1;
        let surferVx = 0;
        let surferVy = 0;
        let attachedWave = null;
        let score = 0;
        let wavesRidden = 0;
        let previousAttachedWave = null;
        let colorIndex = 0;
        let highScores = JSON.parse(localStorage.getItem('highScores')) || Array(10).fill(0);
        let gameLoop;

        // Control variables for analog input
        let horizontalInput = 0;
        let verticalInput = 0;
        let centerX, centerY;
        let halfWidth, halfHeight;

        // Beach heights
        const beachHeights = Array.from({length: VIRTUAL_WIDTH}, () => Math.floor(Math.random() * 5) + 1);

        // Background objects with additional layers
        const backgroundObjects = Array.from({length: 30}, () => {
            const type = ['umbrella', 'person', 'palm', 'rock'][Math.floor(Math.random() * 4)];
            const vcol = Math.random() * VIRTUAL_WIDTH;
            const layer = Math.floor(Math.random() * 4); // 0 to 3
            return { type, vcol, layer };
        });
        const layer_speeds = [0.2, 0.4, 0.6, 0.8];

        // Clouds for wave parallax in sky
        const clouds = Array.from({length: 5}, () => ({ vcol: Math.random() * VIRTUAL_WIDTH, layer: Math.floor(Math.random() * 3) }));
        const cloud_speeds = [0.05, 0.1, 0.15];

        // Mountains for additional depth
        const mountains = Array.from({length: 5}, () => ({ vcol: Math.random() * VIRTUAL_WIDTH, layer: 0 }));
        const mountain_speeds = [0.05];

        // Wave generation
        setInterval(() => {
            const shape = ['sine', 'square', 'triangle'][Math.floor(Math.random() * 3)];
            const A = Math.random() * 10 + 5;
            const K = Math.random() * 0.3 + 0.2;
            const PHI = Math.random() * 2 * Math.PI;
            const color = WAVE_COLORS[colorIndex % WAVE_COLORS.length];
            colorIndex++;
            const VCOL_center = Math.random() * VIRTUAL_WIDTH;
            activeWaves.push({ A, K, PHI, V: WAVE_SPEED, row: 5, color, VCOL_center, shape });
        }, WAVE_INTERVAL);

        // Shark generation
        setInterval(createShark, 25000);

        // Boat generation
        setInterval(createBoat, 50000);

        // Lobster generation
        setInterval(() => {
            const row = Math.floor(Math.random() * (ROWS - 6 - 5)) + 5;
            const VCOL = Math.random() * VIRTUAL_WIDTH;
            const lifespan = 10 + Math.random() * 5;
            lobsters.push({ row, VCOL, lifespan });
        }, 5000);

        // Fish generation
        setInterval(() => {
            const row = Math.floor(Math.random() * (ROWS - 6 - 5)) + 5;
            const VCOL = Math.random() * VIRTUAL_WIDTH;
            const lifespan = 10 + Math.random() * 5;
            fish.push({ row, VCOL, lifespan });
        }, 3000);

        // Start game loop
        gameLoop = setInterval(() => {
            updateGame();
            drawGrid();
        }, DT * 1000);

        // Functions
        function createShark() {
            const row = Math.floor(Math.random() * (SHARK_MAX_ROW - SHARK_MIN_ROW + 1)) + SHARK_MIN_ROW;
            const VCOL = Math.random() * VIRTUAL_WIDTH;
            const speed = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * (SHARK_SPEED_MAX - SHARK_SPEED_MIN) + SHARK_SPEED_MIN);
            const lifespan = 10 + Math.random() * 5;
            sharks.push({ row, VCOL, speed, lifespan });
        }

        function createBoat() {
            const isShip = Math.random() < 1 / 90;
            const type = isShip ? 'ship' : 'boat';
            const row = Math.floor(Math.random() * (BOAT_MAX_ROW - BOAT_MIN_ROW + 1)) + BOAT_MIN_ROW;
            const VCOL = Math.random() * VIRTUAL_WIDTH;
            const speed = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * (BOAT_SPEED_MAX - BOAT_SPEED_MIN) + BOAT_SPEED_MIN);
            const waveTimer = Math.random() * (BOAT_WAVE_INTERVAL_MAX - BOAT_WAVE_INTERVAL_MIN) + BOAT_WAVE_INTERVAL_MIN;
            const lifespan = 10 + Math.random() * 5;
            boats.push({ row, VCOL, speed, waveTimer, type, lifespan });
        }

        function updateGame() {
            t += DT;
            gameTime += DT;

            // Update waves
            activeWaves.forEach(wave => wave.row += wave.V * DT);
            activeWaves = activeWaves.filter(wave => wave.row < ROWS);

            // Update sharks
            sharks.forEach(shark => {
                const dx = surferX - shark.VCOL;
                const dy = surferY - shark.row;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    const speed = 5;
                    shark.VCOL += (dx / distance) * speed * DT;
                    shark.row += (dy / distance) * speed * DT;
                }
                shark.VCOL = (shark.VCOL + VIRTUAL_WIDTH) % VIRTUAL_WIDTH;
                shark.row = Math.max(0, Math.min(ROWS - 1, shark.row));
                shark.lifespan -= DT;
            });
            sharks = sharks.filter(shark => shark.lifespan > 0);

            // Update boats
            boats.forEach(boat => {
                boat.VCOL += boat.speed * DT;
                if (boat.VCOL < 0 || boat.VCOL >= VIRTUAL_WIDTH) boat.speed = -boat.speed;
                boat.waveTimer -= DT;
                if (boat.waveTimer <= 0) {
                    let A = Math.random() * 3 + 2;
                    if (boat.type === 'ship') A *= 10;
                    const K = Math.random() * 0.3 + 0.2;
                    const PHI = Math.random() * 2 * Math.PI;
                    const color = WAVE_COLORS[colorIndex % WAVE_COLORS.length];
                    colorIndex++;
                    const VCOL_center = boat.VCOL;
                    activeWaves.push({ A, K, PHI, V: WAVE_SPEED, row: boat.row, color, VCOL_center });
                    boat.waveTimer = Math.random() * (BOAT_WAVE_INTERVAL_MAX - BOAT_WAVE_INTERVAL_MIN) + BOAT_WAVE_INTERVAL_MIN;
                }
                boat.lifespan -= DT;
            });
            boats = boats.filter(boat => boat.lifespan > 0);

            // Update lobsters and fish
            lobsters.forEach(lobster => lobster.lifespan -= DT);
            lobsters = lobsters.filter(lobster => lobster.lifespan > 0);
            fish.forEach(f => f.lifespan -= DT);
            fish = fish.filter(f => f.lifespan > 0);

            // Handle player movement
            if (!attachedWave) {
                // Analog control for horizontal movement
                surferVx += horizontalInput * ACCELERATION * DT;
                // Analog control for vertical movement
                surferVy += verticalInput * PLAYER_SPEED * DT + GRAVITY * DT;
                surferY += surferVy * DT;
                surferX += surferVx * DT;
                surferVx *= 0.9; // Damping
                if (surferY > ROWS - 1) {
                    surferY = ROWS - 1;
                    surferVy = 0;
                }
            } else {
                // Attached to wave
                surferY = attachedWave.row;
                // Analog control for horizontal movement
                surferVx += horizontalInput * WAVE_ACCELERATION * DT;
                surferX += surferVx * DT;
                surferVx *= 0.9; // Damping
                // Detach from wave if up input is detected
                if (verticalInput < -0.5) {
                    attachedWave = null;
                    surferVy = -JUMP_VELOCITY;
                }
            }

            // Update score
            if (attachedWave && attachedWave !== previousAttachedWave) {
                wavesRidden++;
                score += 100 * wavesRidden;
            }
            if (attachedWave) score += 1;
            previousAttachedWave = attachedWave;
            document.getElementById('current-score').textContent = score;

            // Shark collision
            const surferRow = Math.floor(surferY);
            const surferVCOL = Math.floor(surferX);
            if (sharks.some(shark => Math.floor(shark.row) === surferRow && Math.floor(shark.VCOL) === surferVCOL)) {
                gameOver();
            }

            // Collectibles
            lobsters = lobsters.filter(lobster => {
                const R_lobster = Math.floor(lobster.row);
                const VCOL_lobster = Math.floor(lobster.VCOL);
                if (R_lobster == surferRow && VCOL_lobster == surferVCOL) {
                    score += 300;
                    return false;
                }
                return true;
            });
            fish = fish.filter(f => {
                const R_fish = Math.floor(f.row);
                const VCOL_fish = Math.floor(f.VCOL);
                if (R_fish == surferRow && VCOL_fish == surferVCOL) {
                    score += 50;
                    return false;
                }
                return true;
            });

            // Camera tilt
            const angle = Math.min(Math.max(surferVx * 0.1, -10), 10);
            document.getElementById('gameGrid').style.transform = `rotate(${angle}deg)`;
        }

        function calculateCrestVirtualCol(wave, R) {
            let func;
            switch (wave.shape) {
                case 'sine': func = Math.sin; break;
                case 'square': func = x => Math.sign(Math.sin(x)); break;
                case 'triangle': func = x => 2 * Math.abs(x / (2 * Math.PI) - Math.floor(x / (2 * Math.PI) + 0.5)) - 1; break;
                default: func = Math.sin;
            }
            return (wave.VCOL_center + wave.A * func(wave.K * R + wave.PHI) + VIRTUAL_WIDTH) % VIRTUAL_WIDTH;
        }

        function getWaveChar(distance) {
            if (distance <= 1) return '~';
            else if (distance <= 3) return '-';
            else return '.';
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function interpolate(a, b, ratio) {
            return Math.round(a + (b - a) * ratio);
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        function getBackgroundColor(timeOfDay) {
            const keyPoints = [
                { t: 0.0, color: '#000000' }, { t: 0.1, color: '#FF0000' }, { t: 0.2, color: '#FFFF00' },
                { t: 0.3, color: '#0000FF' }, { t: 0.7, color: '#0000FF' }, { t: 0.8, color: '#FFFF00' },
                { t: 0.9, color: '#FF0000' }, { t: 1.0, color: '#000000' }
            ];
            for (let i = 0; i < keyPoints.length - 1; i++) {
                if (timeOfDay >= keyPoints[i].t && timeOfDay <= keyPoints[i + 1].t) {
                    const t0 = keyPoints[i].t;
                    const t1 = keyPoints[i + 1].t;
                    const c0 = hexToRgb(keyPoints[i].color);
                    const c1 = hexToRgb(keyPoints[i + 1].color);
                    const ratio = (timeOfDay - t0) / (t1 - t0);
                    return rgbToHex(
                        interpolate(c0.r, c1.r, ratio),
                        interpolate(c0.g, c1.g, ratio),
                        interpolate(c0.b, c1.b, ratio)
                    );
                }
            }
            return '#000000';
        }

        function drawGrid() {
            const center_i = Math.floor(COLS / 2);
            const startVCOL = (Math.floor(surferX) - center_i + VIRTUAL_WIDTH) % VIRTUAL_WIDTH;
            let grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => ({char: ' ', color: 'transparent', backgroundColor: ''})));

            // Background color based on time
            const dayCycle = 120;
            const timeOfDay = (gameTime % dayCycle) / dayCycle;
            document.body.style.backgroundColor = getBackgroundColor(timeOfDay);

            // Render sky (rows 0-4)
            let skyColor = timeOfDay < 0.25 ? '#87CEEB' : timeOfDay < 0.5 ? '#BFEFFF' : timeOfDay < 0.75 ? '#FFA500' : '#00008B';
            for (let R = 0; R < 5; R++) {
                for (let i = 0; i < COLS; i++) {
                    grid[R][i].char = '.';
                    grid[R][i].color = skyColor;
                }
            }

            // Render beach with yellow background
            for (let i = 0; i < COLS; i++) {
                const VCOL = (startVCOL + i) % VIRTUAL_WIDTH;
                const h = beachHeights[VCOL];
                for (let k = 0; k < h; k++) {
                    const R = ROWS - h + k;
                    grid[R][i].char = '.';
                    grid[R][i].color = 'black';
                    grid[R][i].backgroundColor = '#FFFF00';
                }
            }

            // Render mountains
            mountains.forEach(mountain => {
                const s = mountain_speeds[mountain.layer];
                let render_vcol = (mountain.vcol - s * surferX) % VIRTUAL_WIDTH;
                if (render_vcol < 0) render_vcol += VIRTUAL_WIDTH;
                const i = ((Math.floor(render_vcol) - startVCOL) % COLS + COLS) % COLS;
                if (i >= 0 && i < COLS) {
                    grid[4][i].char = '^';
                    grid[4][i].color = 'gray';
                }
            });

            // Render clouds
            clouds.forEach(cloud => {
                const s = cloud_speeds[cloud.layer];
                let render_vcol = (cloud.vcol - s * surferX) % VIRTUAL_WIDTH;
                if (render_vcol < 0) render_vcol += VIRTUAL_WIDTH;
                const i = ((Math.floor(render_vcol) - startVCOL) % COLS + COLS) % COLS;
                if (i >= 0 && i < COLS) {
                    const R = Math.floor(Math.random() * 5);
                    grid[R][i].char = 'â˜';
                    grid[R][i].color = 'white';
                }
            });

            // Sun or moon
            const celestialRow = 2;
            const celestialCol = Math.floor((timeOfDay * COLS) % COLS);
            grid[celestialRow][celestialCol].char = timeOfDay < 0.5 ? 'â˜€' : 'ðŸŒ™';
            grid[celestialRow][celestialCol].color = timeOfDay < 0.5 ? 'yellow' : 'white';

            // Stars
            if (timeOfDay >= 0.5 && timeOfDay < 0.75) {
                for (let R = 0; R < 5; R++) {
                    for (let i = 0; i < COLS; i++) {
                        if (Math.random() < 0.01) {
                            grid[R][i].char = '*';
                            grid[R][i].color = 'white';
                        }
                    }
                }
            }

            // Render waves
            activeWaves.forEach(wave => {
                const R_wave = Math.floor(wave.row);
                if (R_wave >= 5 && R_wave < ROWS) {
                    const C = calculateCrestVirtualCol(wave, R_wave);
                    const W = 5;
                    for (let di = -W; di <= W; di++) {
                        const VCOL_wave = (C + di + VIRTUAL_WIDTH) % VIRTUAL_WIDTH;
                        const min_distance_to_surfer = Math.min(Math.abs(VCOL_wave - surferX), VIRTUAL_WIDTH - Math.abs(VCOL_wave - surferX));
                        const distance = Math.abs(di);
                        let char = min_distance_to_surfer < 5 ? '^' : getWaveChar(distance);
                        const i_wave = ((Math.floor(VCOL_wave) - startVCOL) % COLS + COLS) % COLS;
                        if (i_wave >= 0 && i_wave < COLS) {
                            grid[R_wave][i_wave].char = char;
                            grid[R_wave][i_wave].color = wave.color;
                        }
                    }
                }
            });

            // Render sharks
            sharks.forEach(shark => {
                const R_shark = Math.floor(shark.row);
                if (R_shark >= 5 && R_shark < ROWS) {
                    const i_shark = ((Math.floor(shark.VCOL) - startVCOL) % COLS + COLS) % COLS;
                    if (i_shark >= 0 && i_shark < COLS) {
                        grid[R_shark][i_shark].char = 'ðŸ¦ˆ';
                        grid[R_shark][i_shark].color = '#FF0000';
                    }
                }
            });

            // Render boats
            boats.forEach(boat => {
                const R_boat = Math.floor(boat.row);
                if (R_boat >= 5 && R_boat < ROWS) {
                    const i_boat = ((Math.floor(boat.VCOL) - startVCOL) % COLS + COLS) % COLS;
                    if (i_boat >= 0 && i_boat < COLS) {
                        grid[R_boat][i_boat].char = boat.type === 'ship' ? 'ðŸš¢' : 'â›µ';
                        grid[R_boat][i_boat].color = boat.type === 'ship' ? '#808080' : '#8B4513';
                    }
                }
            });

            // Render lobsters
            lobsters.forEach(lobster => {
                const R_lobster = Math.floor(lobster.row);
                if (R_lobster >= 5 && R_lobster < ROWS) {
                    const i_lobster = ((Math.floor(lobster.VCOL) - startVCOL) % COLS + COLS) % COLS;
                    if (i_lobster >= 0 && i_lobster < COLS) {
                        grid[R_lobster][i_lobster].char = 'ðŸ¦ž';
                        grid[R_lobster][i_lobster].color = '#FFA500';
                    }
                }
            });

            // Render fish
            fish.forEach(f => {
                const R_fish = Math.floor(f.row);
                if (R_fish >= 5 && R_fish < ROWS) {
                    const i_fish = ((Math.floor(f.VCOL) - startVCOL) % COLS + COLS) % COLS;
                    if (i_fish >= 0 && i_fish < COLS) {
                        grid[R_fish][i_fish].char = 'ðŸŸ';
                        grid[R_fish][i_fish].color = '#FFFF00';
                    }
                }
            });

            // Render surfer
            const surferR = Math.floor(surferY);
            if (surferR >= 0 && surferR < ROWS) {
                grid[surferR][center_i].char = 'ðŸ„';
                grid[surferR][center_i].color = 'red';
                grid[surferR][center_i].className = 'surfer';
            }

            // Convert grid to HTML
            let html = '';
            grid.forEach(row => {
                html += '<div>';
                row.forEach(cell => {
                    const style = `color: ${cell.color}; background-color: ${cell.backgroundColor || 'transparent'}`;
                    html += `<span class="${cell.className || ''}" style="${style}">${cell.char}</span>`;
                });
                html += '</div>';
            });
            document.getElementById('gameGrid').innerHTML = html;
        }

        function gameOver() {
            clearInterval(gameLoop);
            document.getElementById('gameOverModal').style.display = 'block';
            document.getElementById('finalScore').textContent = score;
            updateHighScores(score);
            document.getElementById('highScoreMessage').style.display = score > highScores[9] ? 'block' : 'none';
        }

        function resetGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            t = 0;
            gameTime = 0;
            activeWaves = [];
            sharks = [];
            boats = [];
            lobsters = [];
            fish = [];
            surferX = VIRTUAL_WIDTH / 2;
            surferY = ROWS - 1;
            surferVx = 0;
            surferVy = 0;
            attachedWave = null;
            score = 0;
            wavesRidden = 0;
            previousAttachedWave = null;
            colorIndex = 0;
            gameLoop = setInterval(() => {
                updateGame();
                drawGrid();
            }, DT * 1000);
        }

        function updateHighScores(newScore) {
            highScores.push(newScore);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 10);
            localStorage.setItem('highScores', JSON.stringify(highScores));
            displayHighScores();
        }

        function displayHighScores() {
            document.getElementById('high-scores').innerHTML = highScores.map(score => `<li>${score}</li>`).join('');
        }

        // Joystick controls
        const joystickArea = document.getElementById('joystickArea');
        joystickArea.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const joystickRect = joystickArea.getBoundingClientRect();
            centerX = joystickRect.left + joystickRect.width / 2;
            centerY = joystickRect.top + joystickRect.height / 2;
            halfWidth = joystickRect.width / 2;
            halfHeight = joystickRect.height / 2;
        });

        joystickArea.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            let touchX = touch.clientX;
            let touchY = touch.clientY;
            let dx = touchX - centerX;
            let dy = touchY - centerY;
            // Clamp within bounds
            dx = Math.max(-halfWidth, Math.min(dx, halfWidth));
            dy = Math.max(-halfHeight, Math.min(dy, halfHeight));
            horizontalInput = dx / halfWidth;
            verticalInput = dy / halfHeight;
        });

        joystickArea.addEventListener('touchend', (e) => {
            e.preventDefault();
            horizontalInput = 0;
            verticalInput = 0;
        });

        document.getElementById('resetButton').addEventListener('click', resetGame);
    </script>
</body>
</html>
